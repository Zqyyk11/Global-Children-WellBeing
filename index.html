<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapping Global Child Well-Being: An Interactive Visualization for Social Good  - D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- D3 color schemes (including magma) -->
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }
        
        /* Tutorial button */
        #tutorial-wrapper {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        #tutorial-btn {
            padding: 16px 32px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        #tutorial-btn:hover {
            background-color: #357abd;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }
        
        #tutorial-hint {
            font-size: 13px;
            color: #666;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        #tutorial-hint-arrow {
            font-size: 16px;
            color: #4a90e2;
        }
        
        /* Tutorial overlay */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none;
            pointer-events: auto;
        }
        
        #tutorial-overlay.active {
            display: block;
        }
        
        /* Interactive steps: no dimming, allow clicks through to page elements */
        #tutorial-overlay.interactive {
            background-color: rgba(0, 0, 0, 0);
            pointer-events: none;
        }
        
        /* Tutorial content and buttons should always be clickable */
        .tutorial-content {
            pointer-events: auto;
            z-index: 2003;
        }
        
        #tutorial-overlay.interactive .tutorial-highlight {
            pointer-events: none;
        }
        
        /* Tutorial highlight box */
        .tutorial-highlight {
            position: fixed;
            border: 4px solid #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 2001;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            transition: all 0.3s;
            border-radius: 4px;
        }
        
        /* Tutorial content box */
        .tutorial-content {
            position: fixed;
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            z-index: 2002;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .tutorial-content h3 {
            margin-top: 0;
            color: #333;
            font-size: 20px;
        }
        
        .tutorial-content p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .tutorial-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-btn-primary {
            background-color: #4a90e2;
            color: white;
        }
        
        .tutorial-btn-primary:hover {
            background-color: #357abd;
        }
        
        .tutorial-btn-secondary {
            background-color: #e0e0e0;
            color: #333;
        }
        
        .tutorial-btn-secondary:hover {
            background-color: #d0d0d0;
        }
        
        .tutorial-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tutorial-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-close:hover {
            color: #333;
        }
        
        .tutorial-step-indicator {
            text-align: center;
            margin-bottom: 15px;
            color: #999;
            font-size: 12px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        #map-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 600px;
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        #map-wrapper {
            display: flex;
            width: 100%;
            max-width: 100%;
            gap: 20px;
            align-items: flex-start;
        }

        #bubble-legend {
            position: relative;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            min-width: 240px;
            max-width: 240px;
            flex-shrink: 0;
            transition: max-width 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
        }

        #bubble-legend.collapsed {
            max-width: 50px;
            padding: 10px 5px;
            overflow: hidden;
        }

        #bubble-legend.collapsed #legend-content {
            opacity: 0;
            pointer-events: none;
            height: 0;
            overflow: hidden;
        }

        #bubble-legend h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }

        #bubble-legend h4::after {
            content: '‚ñº';
            position: absolute;
            right: 0;
            font-size: 10px;
            transition: transform 0.3s ease;
        }

        #bubble-legend.collapsed h4::after {
            transform: rotate(-90deg);
        }

        #legend-content {
            transition: opacity 0.3s ease;
        }

        .legend-section {
            margin-bottom: 20px;
        }

        .legend-section-title {
            font-size: 12px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .legend-item-text {
            font-size: 11px;
            color: #333;
        }

        .legend-color-scale {
            width: 100%;
            height: 20px;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 8px;
            background: linear-gradient(to right, 
                #000004, #1b0c42, #4a0e6e, #781c6d, #a52c60, #cf4446, 
                #ed6925, #fb9a06, #f7d03c, #fcffa4);
        }

        .legend-scale-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }

        .legend-outline {
            width: 30px;
            height: 20px;
            border: 3px solid #ffd700;
            border-radius: 2px;
            margin-right: 10px;
            flex-shrink: 0;
            background-color: #f9f9f9;
        }

        .legend-outline-hover {
            width: 30px;
            height: 20px;
            border: 1.5px solid #333;
            border-radius: 2px;
            margin-right: 10px;
            flex-shrink: 0;
            background-color: #f9f9f9;
        }

        .legend-grey {
            width: 30px;
            height: 20px;
            background-color: #e0e0e0;
            border: 0.5px solid #fff;
            border-radius: 2px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        #map-svg-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 0;
            overflow: hidden;
        }

        #map-svg-container svg {
            max-width: 100%;
            height: auto;
            cursor: grab;
        }

        #map-svg-container svg:active {
            cursor: grabbing;
        }

        .map-group {
            cursor: grab;
        }

        .map-group:active {
            cursor: grabbing;
        }

        .controls {
            margin-bottom: 15px;
            font-size: 12px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .controls strong {
            display: block;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.5px;
        }

        .controls label {
            display: block;
            cursor: pointer;
            margin: 4px 0;
            font-size: 11px;
        }
        
        .country {
            fill: #e0e0e0;
            stroke: #fff;
            stroke-width: 0.5px;
            cursor: pointer;
            transition: stroke-width 0.2s, stroke 0.2s;
        }
        
        .country:hover {
            /* Emphasize outline on hover without changing fill color scale */
            stroke: #333;
            stroke-width: 1.5px;
        }
        
        .country.selected {
            /* Gold outline ‚Äúhalo‚Äù for selected country */
            stroke: #ffd700;
            stroke-width: 3px;
        }
        
        #info-panel {
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #4a90e2;
            min-height: 400px;
            position: relative;
            transform: translateY(0);
            transition: transform 0.35s ease, box-shadow 0.35s ease;
        }

        #data-description {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        #data-description h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 14px;
        }

        #data-description p {
            margin: 8px 0;
            color: #666;
            font-size: 12px;
        }

        /* Temporary "pop" effect to draw attention when a country is selected */
        #info-panel.pop {
            transform: translateY(-300px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18);
        }
        
        #info-panel h3 {
            margin-top: 0;
            color: #333;
            margin-bottom: 20px;
        }
        
        #info-panel p {
            margin: 5px 0;
            color: #666;
        }

        #tree-container {
            display: flex;
            gap: 40px;
            justify-content: space-around;
            min-height: 350px;
        }

        .tree-wrapper {
            flex: 1;
            min-width: 0;
        }

        .tree-svg {
            width: 100%;
            height: 350px;
        }

        .tree-node {
            cursor: pointer;
        }

        .tree-node circle {
            fill: #fff;
            stroke: #4a90e2;
            stroke-width: 2px;
        }

        .tree-node.root circle {
            fill: #4a90e2;
            stroke: #2c5aa0;
            stroke-width: 3px;
            r: 60;
        }

        .tree-node.leaf circle {
            r: 8;
        }

        .tree-node text {
            font-size: 11px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .tree-node.root text {
            font-weight: bold;
            font-size: 14px;
            fill: #000;
        }

        .tree-node.leaf text {
            fill: #333;
        }

        .tree-link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        .tree-value {
            font-size: 10px;
            fill: #666;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Bubble chart styles - positioned on map */
        .bubble-overlay {
            pointer-events: none;
        }

        .bubble {
            fill-opacity: 0.8;
            stroke: #333;
            stroke-width: 2px;
            cursor: pointer;
            transition: fill-opacity 0.3s, stroke-width 0.3s;
            pointer-events: all;
        }

        .bubble:hover {
            fill-opacity: 1;
            stroke-width: 3px;
        }

        .bubble-label {
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .bubble-value {
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }

        .bubble-dimension-label {
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
            font-size: 10px;
            font-weight: 500;
        }

        /* View toggle styles */
        .view-toggle {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .view-toggle button {
            padding: 10px 20px;
            font-size: 14px;
            border: 2px solid #4a90e2;
            border-radius: 6px;
            background-color: white;
            color: #4a90e2;
            cursor: pointer;
            transition: all 0.3s;
        }

        .view-toggle button.active {
            background-color: #4a90e2;
            color: white;
        }

        .view-toggle button:hover {
            background-color: #f0f7ff;
        }

        .view-toggle button.active:hover {
            background-color: #357abd;
        }

        /* Comparison mode styles */
        .comparison-mode-indicator {
            text-align: center;
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #856404;
        }

        .country.selected-1 {
            stroke: #ffd700;
            stroke-width: 3px;
        }

        .country.selected-2 {
            stroke: #4a90e2;
            stroke-width: 3px;
        }

        /* Comparison panel styles */
        #comparison-panel {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 2px solid #4a90e2;
            position: relative;
            transform: translateY(0);
            transition: transform 0.35s ease, box-shadow 0.35s ease;
        }

        #comparison-panel.active {
            display: block;
        }

        /* Temporary "pop" effect to draw attention when a country is selected */
        #comparison-panel.pop {
            transform: translateY(-300px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18);
        }

        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4a90e2;
        }

        .comparison-header h3 {
            margin: 0;
            color: #333;
        }

        .clear-selection-btn {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .clear-selection-btn:hover {
            background-color: #c82333;
        }

        .comparison-countries-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .comparison-country-header {
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .comparison-country-header.country-1 {
            border-left: 4px solid #ffd700;
        }

        .comparison-country-header.country-2 {
            border-left: 4px solid #4a90e2;
        }

        .comparison-country-header h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        }

        .comparison-country-header p {
            margin: 5px 0;
            font-size: 13px;
            color: #666;
        }

        .comparison-radar-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            margin-top: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
        }

        .radar-description-container {
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 2px solid #ddd;
            flex: 0 0 350px;
            max-width: 350px;
        }

        .radar-description-container p {
            margin: 8px 0;
            font-size: 14px;
            color: #666;
            line-height: 1.6;
        }

        .radar-description-container .missing-data {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .radar-description-container .missing-data-title {
            font-size: 14px;
            font-weight: bold;
            color: #d35400;
            margin-bottom: 8px;
        }

        .radar-description-container .missing-data-item {
            font-size: 13px;
            color: #d35400;
            margin: 5px 0;
        }

        .radar-description-container .complete-data {
            font-size: 14px;
            color: #27ae60;
            font-style: italic;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .radar-chart {
            width: 100%;
            max-width: 1100px;
            height: auto;
        }

        .comparison-value {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }

        .comparison-value.country-1 {
            color: #ffd700;
        }

        .comparison-value.country-2 {
            color: #4a90e2;
        }

    </style>
</head>
<body>
    <div id="tutorial-wrapper">
        <button id="tutorial-btn">üìö Tutorial</button>
        <div id="tutorial-hint">
            <span id="tutorial-hint-arrow">‚Üë</span>
            <span>Feeling lost? Start here!</span>
        </div>
    </div>
    
    <div id="tutorial-overlay">
        <div class="tutorial-highlight" id="tutorial-highlight"></div>
        <div class="tutorial-content" id="tutorial-content">
            <button class="tutorial-close" id="tutorial-close">√ó</button>
            <div class="tutorial-step-indicator" id="tutorial-step-indicator">Step 1 of 8</div>
            <h3 id="tutorial-title">Welcome to the Tutorial</h3>
            <p id="tutorial-text">This tutorial will guide you through all the interactive features of this visualization.</p>
            <div class="tutorial-nav">
                <button class="tutorial-btn tutorial-btn-secondary" id="tutorial-prev">Previous</button>
                <button class="tutorial-btn tutorial-btn-primary" id="tutorial-next">Next</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h1>Mapping Global Child Well-Being:<br>An Interactive Visualization for Social Good </h1>
        <p class="subtitle">Click on any country to view its data ‚Ä¢ Scroll to zoom, drag to pan</p>

        <div class="view-toggle">
            <button id="default-view-btn" class="active">Default View</button>
            <button id="comparison-view-btn">Comparison View</button>
        </div>
        
        <div id="map-container">
            <div id="map-wrapper">
                <div id="bubble-legend">
                    <h4 id="legend-toggle">Map Legend</h4>
                    <div id="legend-content">
                        <div class="controls" id="metric-controls">
                            <strong>Colour by:</strong>
                            <label>
                                <input type="radio" name="metric-filter" value="aggregate" checked>
                                Aggregate Index
                            </label>
                            <label>
                                <input type="radio" name="metric-filter" value="happiness">
                                Happiness Rank
                            </label>
                            <label>
                                <input type="radio" name="metric-filter" value="mortality">
                                Child Mortality Rate
                            </label>
                            <label>
                                <input type="radio" name="metric-filter" value="education">
                                Primary School Completion Rate
                            </label>
                            <label>
                                <input type="radio" name="metric-filter" value="nutrition">
                                Children with Stunted Growth
                            </label>
                            <label>
                                <input type="radio" name="metric-filter" value="sanitation">
                                Households with Basic Sanitation
                            </label>
                        </div>
                        <div id="legend-items"></div>
                        <div id="bubble-description" style="margin-top: 20px; padding: 12px; background-color: #f0f0f0; border-radius: 4px; font-size: 11px; line-height: 1.5; color: #333;">
                            <strong>Bubble Chart:</strong> When you select a country, branching bubbles appear showing key data dimensions. Each bubble's color hue encodes the z-score of that dimension using the magma color scale (darker = lower z-score, lighter = higher z-score).
                        </div>
                    </div>
                </div>
                <div id="map-svg-container">
                    <div class="loading">Loading world map...</div>
                </div>
            </div>
        </div>
        
        <div id="info-panel">
            <h3 id="country-name">Select a country to view details!</h3>
            <div id="tree-container"></div>
        </div>

        <div id="comparison-panel">
            <div class="comparison-header">
                <h3>Country Comparison</h3>
                <button class="clear-selection-btn" id="clear-selection-btn">Clear Selection</button>
            </div>
            <div class="comparison-countries-list" id="comparison-countries-list"></div>
            <div class="comparison-radar-container" id="comparison-radar-container"></div>
        </div>

    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        // Set up dimensions and projection
        const width = 1200;
        const height = 600;
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        
        // Create SVG
        const svg = d3.select("#map-svg-container")
            .html("") // Clear loading message
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("preserveAspectRatio", "xMidYMid meet");
        
        // Create a group for all map elements that will be transformed by zoom
        const mapGroup = svg.append("g").attr("class", "map-group");
        
        // Create tooltip
        const tooltip = d3.select("#tooltip");
        
        // Create projection (Mercator projection)
        const projection = d3.geoMercator()
            .scale(width / 6.5)
            .translate([width / 2, height / 1.5]);
        
        // Create path generator
        const path = d3.geoPath().projection(projection);
        
        // Create zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.5, 8]) // Limit zoom between 0.5x and 8x
            .on("zoom", function(event) {
                mapGroup.attr("transform", event.transform);
            });
        
        // Apply zoom to SVG
        svg.call(zoom);
        
        // Store country data (keyed by CSV "country" column)
        let countryData = {};
        let selectedCountry = null;
        let wellbeingColorScale = null; // color scale for child_wellbeing_index
        let activeMetricKey = "aggregate"; // which metric is driving the color scale
        
        // Comparison mode state
        let comparisonMode = false;
        let comparisonCountries = []; // Array to hold multiple countries

        // Mapping from UI filter to CSV z-score field
        const metricConfig = {
            aggregate: {
                field: "child_wellbeing_index",
                label: "Aggregate Index"
            },
            happiness: {
                field: "happiness_rank",
                label: "Happiness Rank"
            },
            mortality: {
                field: "among5_14_mortality_rate_2022",
                label: "Child Mortality"
            },
            education: {
                field: "completion_rate_2000_2023_primary",
                label: "Primary School Completion Rate"
            },
            nutrition: {
                field: "stunted_perc_2022",
                label: "Children with Stunted Growth"
            },
            sanitation: {
                field: "basic_sanitation_household_perc_2022",
                label: "Households with Basic Sanitation"
            }
        };
        
        // Country name mapping for common variations
        // Keys are map names (from topojson), values are CSV "country" names
        const countryNameMap = {
            "United States of America": "United States",
            "Russian Federation": "Russia",
            "United Kingdom": "United Kingdom",
            "Czech Republic": "Czechia",
            "Central African Rep.": "Central African Republic",
            "Republic of the Congo": "Congo (Brazzaville)",
            "Democratic Republic of the Congo": "Congo (Kinshasa)",
            "Myanmar": "Myanmar",
            "Palestine": "State of Palestine",
            "Syria": "Syrian Arab Republic",
            "South Korea": "Republic of Korea",
            "Korea, South": "Republic of Korea",
            "North Korea": "Democratic People's Republic of Korea",
            "Korea, North": "Democratic People's Republic of Korea",
            "Iran": "Iran",
            "Laos": "Laos",
            "Vietnam": "Vietnam",
            "Macedonia": "North Macedonia"
        };
        
        // Function to find matching country data
        function findCountryData(countryName) {
            // Direct match
            if (countryData[countryName]) {
                return countryData[countryName];
            }
            
            // Check mapped names
            const mappedName = countryNameMap[countryName];
            if (mappedName && countryData[mappedName]) {
                return countryData[mappedName];
            }
            
            // Try case-insensitive partial match
            const lowerName = countryName.toLowerCase();
            for (const csvName in countryData) {
                if (csvName.toLowerCase() === lowerName || 
                    csvName.toLowerCase().includes(lowerName) ||
                    lowerName.includes(csvName.toLowerCase())) {
                    return countryData[csvName];
                }
            }
            
            return null;
        }
        
        // Update country fill colors based on selected metric using the d3 magma palette
        function updateCountryColors() {
            // Lazily (re)build color scale if needed from currently loaded data
            if (!wellbeingColorScale) {
                const metric = metricConfig[activeMetricKey];
                if (!metric) {
                    console.warn("Unknown metric key:", activeMetricKey);
                    return;
                }
                const fieldName = metric.field;

                const allRows = Object.values(countryData || {});
                const values = allRows
                    .map(d => +d[fieldName])
                    .filter(v => !isNaN(v));

                if (values.length > 0) {
                    const extent = d3.extent(values);
                    // Use official d3.interpolateMagma from d3-scale-chromatic
                    wellbeingColorScale = d3.scaleSequential(d3.interpolateMagma)
                        .domain(extent);
                } else {
                    console.warn("No valid child_wellbeing_index values found for color scale.");
                    return;
                }
            }
            
            const metric = metricConfig[activeMetricKey];
            if (!metric) return;
            const fieldName = metric.field;

            mapGroup.selectAll(".country")
                .style("fill", function(d) {
                    const name = d.properties.NAME || d.properties.name || "Unknown";
                    const data = findCountryData(name);
                    
                    if (data && data[fieldName] !== undefined && data[fieldName] !== "") {
                        const val = +data[fieldName];
                        if (!isNaN(val)) {
                            return wellbeingColorScale(val);
                        }
                    }
                    
                    // Default neutral grey for countries without index data
                    return "#e0e0e0";
                });
        }
        
        // Load world map data from Natural Earth
        // Using a reliable CDN source for world map TopoJSON
        d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
            .then(function(world) {
                // Convert TopoJSON to GeoJSON
                const countries = topojson.feature(world, world.objects.countries);
                
                // Draw countries in the map group
                mapGroup.selectAll(".country")
                    .data(countries.features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .attr("data-name", d => d.properties.NAME || d.properties.name || "Unknown")
                    .on("click", function(event, d) {
                        event.stopPropagation(); // Prevent zoom on click
                        const countryName = d.properties.NAME || d.properties.name || "Unknown";
                        handleCountryClick(countryName, d);
                    })
                    .on("mouseover", function(event, d) {
                        const countryName = d.properties.NAME || d.properties.name || "Unknown";
                        showTooltip(event, countryName);
                        
                        // Highlight on hover
                        d3.select(this).classed("hover", true);
                    })
                    .on("mouseout", function() {
                        hideTooltip();
                        d3.select(this).classed("hover", false);
                    });
                
                console.log("World map loaded successfully!");

                // Update bubbles when data is loaded
                if (Object.keys(countryData).length > 0) {
                updateCountryColors();
                }
            })
            .catch(function(error) {
                console.error("Error loading map:", error);
                d3.select("#map-svg-container")
                    .html(`<div class="loading" style="color: red;">Error loading map data. Please check your internet connection or try a different data source.</div>`);
            });
        
        // Function to handle country click
        function handleCountryClick(countryName, geoData) {
            // Check if we have data for this country (with smart matching)
            const data = findCountryData(countryName);
            
            // If there's no associated data (e.g., Greenland, some territories),
            // make the country effectively unselectable.
            if (!data) {
                console.log(`No data available for "${countryName}", click ignored.`);
                return;
            }

            if (comparisonMode) {
                // Comparison mode: select up to two countries
                handleComparisonClick(countryName, geoData);
            } else {
                // Default mode: single country selection
                handleDefaultClick(countryName, geoData);
            }
        }
        
        // Handle click in default mode
        function handleDefaultClick(countryName, geoData) {
            // Remove previous selection
            mapGroup.selectAll(".country")
                .classed("selected", false)
                .classed("selected-1", false)
                .classed("selected-2", false);
            
            // Add selection to clicked country
            mapGroup.selectAll(".country")
                .filter(d => (d.properties.NAME || d.properties.name || "Unknown") === countryName)
                .classed("selected", true);
            
            selectedCountry = countryName;
            
            // Show info panel, hide comparison panel
            const infoPanel = d3.select("#info-panel");
            infoPanel.style("display", "block");
            d3.select("#comparison-panel").classed("active", false);

            // Brief "pop up" animation to draw attention
            infoPanel.classed("pop", false);
            if (infoPanel.node()) {
                infoPanel.node().offsetWidth;
            }
            infoPanel.classed("pop", true);
            setTimeout(() => {
                infoPanel.classed("pop", false);
            }, 500);
            
            // Update country name
            d3.select("#country-name").text(countryName);

            // Display country data
            const data = findCountryData(countryName);
            displayCountryData(data, geoData);
            
            // Advance tutorial if waiting for country click
            advanceTutorialOnAction("countryClick");
        }
        
        // Handle click in comparison mode
        function handleComparisonClick(countryName, geoData) {
            const index = comparisonCountries.indexOf(countryName);
            
            if (index > -1) {
                // Country already selected, deselect it
                comparisonCountries.splice(index, 1);
                mapGroup.selectAll(".country")
                    .filter(d => (d.properties.NAME || d.properties.name || "Unknown") === countryName)
                    .classed("selected-1", false)
                    .classed("selected-2", false);
            } else {
                // Add country to comparison
                comparisonCountries.push(countryName);
                // Apply visual class based on position (alternate between selected-1 and selected-2)
                const classToApply = comparisonCountries.length % 2 === 1 ? "selected-1" : "selected-2";
                mapGroup.selectAll(".country")
                    .filter(d => (d.properties.NAME || d.properties.name || "Unknown") === countryName)
                    .classed(classToApply, true);
                
                // Advance tutorial if waiting for comparison country click
                advanceTutorialOnAction("comparisonCountryClick");
            }
            
            updateComparisonDisplay();
        }
        
        // Clear all selections
        function clearComparisonSelections() {
            comparisonCountries = [];
            mapGroup.selectAll(".country")
                .classed("selected-1", false)
                .classed("selected-2", false);
            // Remove bubble chart overlay
            mapGroup.selectAll(".bubble-overlay").remove();
            updateComparisonDisplay();
        }
        
        // Update comparison display
        function updateComparisonDisplay() {
            // Hide info panel, show comparison panel
            d3.select("#info-panel").style("display", "none");
            const comparisonPanel = d3.select("#comparison-panel");
            comparisonPanel.classed("active", true);
            
            if (comparisonCountries.length === 0) {
                // Clear the display but show empty state message
                d3.select("#comparison-countries-list").html("");
                const radarContainer = d3.select("#comparison-radar-container");
                radarContainer.html("");
                radarContainer.append("div")
                    .style("text-align", "center")
                    .style("padding", "100px 20px")
                    .style("color", "#666")
                    .style("font-size", "18px")
                    .text("Select a country to start comparing!");
                return;
            }
            
            // Brief "pop up" animation to draw attention
            comparisonPanel.classed("pop", false);
            if (comparisonPanel.node()) {
                comparisonPanel.node().offsetWidth; // Force reflow
            }
            comparisonPanel.classed("pop", true);
            setTimeout(() => {
                comparisonPanel.classed("pop", false);
            }, 500);
            
            // Update countries list
            const countriesList = d3.select("#comparison-countries-list");
            countriesList.html("");
            
            comparisonCountries.forEach((countryName, index) => {
                const countryDiv = countriesList.append("div")
                    .attr("class", "comparison-country-header")
                    .classed("country-1", index % 2 === 0)
                    .classed("country-2", index % 2 === 1);
                
                const data = findCountryData(countryName);
                if (data) {
                    countryDiv.append("h4").text(countryName);
                    countryDiv.append("p").html(`<strong>Index:</strong> ${fmt(data["child_wellbeing_index"], 2)}`);
                }
            });
            
            // Show radar chart if at least one country selected
            if (comparisonCountries.length > 0) {
                displayRadarComparison();
            }
        }
        
        // Display radar chart comparison
        function displayRadarComparison() {
            const container = d3.select("#comparison-radar-container");
            container.html("");
            
            // Define statistics for radar chart (matching color-by legend, using z-scores)
            const stats = [
                {
                    name: "Child Mortality",
                    field: "among5_14_mortality_rate_2022",
                    zScoreField: "among5_14_mortality_rate_2022"
                },
                {
                    name: "Primary Completion",
                    field: "completion_rate_2000_2023_primary",
                    zScoreField: "completion_rate_2000_2023_primary"
                },
                {
                    name: "Basic Sanitation",
                    field: "basic_sanitation_household_perc_2022",
                    zScoreField: "basic_sanitation_household_perc_2022"
                },
                {
                    name: "Children with Stunted Growth",
                    field: "stunted_perc_2022",
                    zScoreField: "stunted_perc_2022"
                },
                {
                    name: "Happiness Rank",
                    field: "happiness_rank",
                    zScoreField: "happiness_rank"
                }
            ];
            
            // Collect data for all selected countries (using z-scores)
            const countriesData = comparisonCountries.map(countryName => {
                const data = findCountryData(countryName);
                if (!data) return null;
                
                return {
                    name: countryName,
                    data: data,
                    values: stats.map(stat => {
                        const zScoreValue = data[stat.zScoreField];
                        return isMissing(zScoreValue) ? null : parseFloat(zScoreValue);
                    }),
                    missing: stats.map(stat => isMissing(data[stat.zScoreField]))
                };
            }).filter(d => d !== null);
            
            if (countriesData.length === 0) return;
            
            // Calculate global means for each stat (using z-scores)
            const globalMeans = stats.map((stat, i) => {
                const allCountryData = Object.values(countryData);
                const validValues = allCountryData
                    .map(d => parseFloat(d[stat.zScoreField]))
                    .filter(v => !isNaN(v) && v !== null && v !== undefined && v !== "");
                return validValues.length > 0 
                    ? validValues.reduce((sum, val) => sum + val, 0) / validValues.length 
                    : null;
            });
            
            // Normalize values for radar chart (0-100 scale based on z-score range)
            // Z-scores typically range from about -3 to +3, so we'll normalize to that range
            const zScoreMin = -3;
            const zScoreMax = 3;
            const zScoreRange = zScoreMax - zScoreMin;
            
            // Track missing values for display
            const missingDataInfo = [];
            countriesData.forEach((country, idx) => {
                const missingFields = [];
                country.missing.forEach((isMissing, i) => {
                    if (isMissing) {
                        missingFields.push(stats[i].name);
                    }
                });
                if (missingFields.length > 0) {
                    missingDataInfo.push({
                        country: country.name,
                        fields: missingFields
                    });
                }
            });
            
            // Create normalized data for countries (normalize z-scores to 0-100)
            // Missing values are set to 0
            const normalizedData = countriesData.map((country, idx) => ({
                name: country.name,
                values: country.values.map((val, i) => {
                    if (val === null) return 0; // Missing values become 0
                    // Normalize z-score to 0-100 scale
                    const normalized = ((val - zScoreMin) / zScoreRange) * 100;
                    return Math.max(0, Math.min(100, normalized)); // Clamp to 0-100
                }),
                missing: country.missing
            }));
            
            // Create normalized data for global mean
            const normalizedGlobalMean = {
                name: "Global Mean",
                values: globalMeans.map((mean, i) => {
                    if (mean === null) return 0;
                    const normalized = ((mean - zScoreMin) / zScoreRange) * 100;
                    return Math.max(0, Math.min(100, normalized));
                }),
                missing: globalMeans.map(mean => mean === null)
            };
            
            // Create a wrapper for the chart
            const chartWrapper = container.append("div")
                .style("flex", "0 0 auto");
            
            // Create radar chart
            createRadarChart(chartWrapper.node(), normalizedData, stats, normalizedGlobalMean, missingDataInfo);
            
            // Create separate description container beside the chart
            const descriptionContainer = container.append("div")
                .attr("class", "radar-description-container");
            
            // Add radar chart description
            descriptionContainer.append("p")
                .text("This radar chart compares selected countries across key dimensions using z-scores. ");
            
            descriptionContainer.append("p")
                .text("Z-scores indicate how many standard deviations each country's value is from the global mean for that dimension. ");
            
            descriptionContainer.append("p")
                .text("Values are normalized to a 0-100 scale, where 0 represents -3 standard deviations and 100 represents +3 standard deviations. ");
            
            descriptionContainer.append("p")
                .text("The purple line shows the global mean for reference. ");
            
            // Add missing data information if any
            if (missingDataInfo && missingDataInfo.length > 0) {
                const missingDataDiv = descriptionContainer.append("div")
                    .attr("class", "missing-data");
                
                missingDataDiv.append("div")
                    .attr("class", "missing-data-title")
                    .text("Missing Data:");
                
                missingDataInfo.forEach((info, idx) => {
                    missingDataDiv.append("div")
                        .attr("class", "missing-data-item")
                        .text(`${info.country}: ${info.fields.join(", ")}`);
                });
            } else {
                descriptionContainer.append("div")
                    .attr("class", "complete-data")
                    .text("All selected countries have complete data for all dimensions.");
            }
        }
        
        // Create radar chart
        function createRadarChart(container, data, stats, globalMean = null, missingDataInfo = []) {
            const chartWidth = 600;
            const chartHeight = 600;
            const width = chartWidth;
            // Calculate legend height based on number of items
            const legendItems = data.length + (globalMean ? 1 : 0);
            const legendHeight = (legendItems * 25); // Top margin (10px) + items (25px each)
            const height = chartHeight + legendHeight - 20; // Chart + legend + minimal gap (reduced from 20 to 5)
            const margin = { top: 60, right: 180, bottom: 80, left: 120 };
            const radius = Math.min(chartWidth, chartHeight) / 2 - Math.max(margin.top, margin.right);
            // Center the chart in the SVG, positioned close to legend above
            const centerX = width / 2;
            const centerY = legendHeight + 2 + (chartHeight / 2); // Minimal gap (2px) between legend and chart
            
            const svg = d3.select(container)
                .append("svg")
                .attr("class", "radar-chart")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);
            
            // Calculate angles manually to ensure even distribution
            // For 5 categories, each should be 2œÄ/5 radians apart
            // Start from top (-œÄ/2) and go clockwise
            const numStats = stats.length;
            const angleStep = (2 * Math.PI) / numStats;
            
            // Function to get angle for a given index
            const getAngle = (index) => {
                // Start from top (-œÄ/2) and go clockwise
                return (index * angleStep) - (Math.PI / 2);
            };
            
            // Find the maximum value across all data (countries + global mean) to scale to edge
            const allValues = [
                ...data.flatMap(d => d.values),
                ...(globalMean ? globalMean.values : [])
            ];
            const maxValue = allValues.length > 0 ? Math.max(...allValues) : 100; // Use actual max, or 100 if no data
            
            const radiusScale = d3.scaleLinear()
                .domain([0, maxValue])
                .range([0, radius]);
            
            // Color scale for countries
            const colors = d3.scaleOrdinal()
                .domain(data.map(d => d.name))
                .range(["#ffd700", "#4a90e2", "#ff6b6b", "#50c878", "#ffa500", "#9b59b6", "#e74c3c", "#3498db"]);
            
            // Color for global mean (different from missing data grey)
            const globalMeanColor = "#6c5ce7";
            
            // Draw grid circles (5 levels, scaled to maxValue)
            for (let i = 1; i <= 5; i++) {
                const gridValue = (i / 5) * maxValue; // Scale grid to maxValue
                g.append("circle")
                    .attr("r", radiusScale(gridValue))
                    .attr("fill", "none")
                    .attr("stroke", "#ddd")
                    .attr("stroke-width", 1);
            }
            
            // Draw grid lines (axes) and labels
            stats.forEach((stat, i) => {
                const angle = getAngle(i);
                const x = Math.sin(angle) * radius;
                const y = -Math.cos(angle) * radius;
                
                // Draw axis line
                g.append("line")
                    .attr("x1", 0)
                    .attr("y1", 0)
                    .attr("x2", x)
                    .attr("y2", y)
                    .attr("stroke", "#ddd")
                    .attr("stroke-width", 1);
                
                // Add axis labels aligned with vertices
                const labelRadius = radius + 35; // Distance from center for labels
                const labelX = Math.sin(angle) * labelRadius;
                const labelY = -Math.cos(angle) * labelRadius;
                
                // Determine text anchor and alignment based on angle to align with axis
                let textAnchor = "middle";
                let labelOffsetX = 0;
                let labelOffsetY = 0;
                
                // Adjust based on angle to align with axis direction
                if (angle > -Math.PI / 6 && angle < Math.PI / 6) {
                    // Right side (0 to 30 degrees)
                    textAnchor = "start";
                    labelOffsetX = 8;
                } else if (angle > Math.PI / 6 && angle < 5 * Math.PI / 6) {
                    // Bottom right to bottom left (30 to 150 degrees)
                    textAnchor = "middle";
                    labelOffsetY = 4;
                } else if (angle > 5 * Math.PI / 6 || angle < -5 * Math.PI / 6) {
                    // Left side (150 to -150 degrees)
                    textAnchor = "end";
                    labelOffsetX = -8;
                } else {
                    // Top left to top right (-150 to -30 degrees)
                    textAnchor = "middle";
                    labelOffsetY = -4;
                }
                
                // Apply specific adjustments for certain labels
                if (stat.name === "Primary Completion") {
                    labelOffsetX -= 10; // Shift slightly to the left
                } else if (stat.name === "Happiness Rank") {
                    labelOffsetX += 10; // Shift slightly to the right
                } else if (stat.name === "Child Mortality") {
                    labelOffsetY += 3; // Shift very slightly downward
                }
                
                g.append("text")
                    .attr("x", labelX + labelOffsetX)
                    .attr("y", labelY + labelOffsetY)
                    .attr("text-anchor", textAnchor)
                    .attr("dominant-baseline", "middle")
                    .attr("font-size", "12px")
                    .attr("fill", "#333")
                    .attr("font-weight", "500")
                    .text(stat.name);
            });
            
            // Helper function to create path with missing data handling
            function createPathWithMissing(pathPoints, closePath = true) {
                let pathString = "";
                let segments = [];
                let currentSegment = [];
                
                // Group consecutive points into segments
                pathPoints.forEach((point, i) => {
                    if (point.isMissing) {
                        // If we have a current non-missing segment, save it
                        if (currentSegment.length > 0) {
                            segments.push({ points: currentSegment, isMissing: false });
                            currentSegment = [];
                        }
                        // Missing points go to center (radius 0) with dashed line
                        segments.push({ 
                            points: [{ ...point, radius: 0 }], 
                            isMissing: true 
                        });
                    } else {
                        currentSegment.push(point);
                    }
                });
                
                // Add final segment if exists
                if (currentSegment.length > 0) {
                    segments.push({ points: currentSegment, isMissing: false });
                }
                
                // Build path string from segments
                segments.forEach((segment, segIdx) => {
                    if (segment.isMissing) {
                        // For missing segments, draw line to center
                        segment.points.forEach((point, i) => {
                            const x = Math.sin(point.angle) * point.radius;
                            const y = -Math.cos(point.angle) * point.radius;
                            if (i === 0) {
                                pathString += `M ${x} ${y}`;
                            } else {
                                pathString += ` L ${x} ${y}`;
                            }
                        });
                    } else {
                        // For non-missing segments, draw normal path
                        segment.points.forEach((point, i) => {
                            const x = Math.sin(point.angle) * point.radius;
                            const y = -Math.cos(point.angle) * point.radius;
                            if (i === 0) {
                                pathString += `M ${x} ${y}`;
                            } else {
                                pathString += ` L ${x} ${y}`;
                            }
                        });
                        if (closePath && segment.points.length > 2) {
                            pathString += " Z";
                        }
                    }
                });
                
                return pathString;
            }
            
            // Draw global mean first (so it appears behind country data)
            if (globalMean) {
                const pathPoints = globalMean.values.map((value, i) => {
                    const angle = getAngle(i);
                    const r = radiusScale(value);
                    return {
                        angle: angle,
                        radius: r,
                        value: value
                    };
                });
                
                // Draw all segments as solid lines (missing values are 0)
                pathPoints.forEach((point, i) => {
                    const nextPoint = pathPoints[(i + 1) % pathPoints.length];
                    const x1 = Math.sin(point.angle) * point.radius;
                    const y1 = -Math.cos(point.angle) * point.radius;
                    const x2 = Math.sin(nextPoint.angle) * nextPoint.radius;
                    const y2 = -Math.cos(nextPoint.angle) * nextPoint.radius;
                    
                    // Draw solid line for all segments
                    g.append("line")
                        .attr("x1", x1)
                        .attr("y1", y1)
                        .attr("x2", x2)
                        .attr("y2", y2)
                        .attr("stroke", globalMeanColor)
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.7);
                });
                
                // Add points for global mean
                pathPoints.forEach((point, i) => {
                    const x = Math.sin(point.angle) * point.radius;
                    const y = -Math.cos(point.angle) * point.radius;
                    
                    g.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 3)
                        .attr("fill", globalMeanColor)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1.5);
                });
            }
            
            // Draw data lines for each country
            data.forEach((country, countryIdx) => {
                // Build path data with proper angles
                const pathPoints = country.values.map((value, i) => {
                    const angle = getAngle(i);
                    const r = radiusScale(value);
                    return {
                        angle: angle,
                        radius: r,
                        value: value
                    };
                });
                
                // Draw all segments as solid lines (missing values are 0)
                pathPoints.forEach((point, i) => {
                    const nextPoint = pathPoints[(i + 1) % pathPoints.length];
                    const x1 = Math.sin(point.angle) * point.radius;
                    const y1 = -Math.cos(point.angle) * point.radius;
                    const x2 = Math.sin(nextPoint.angle) * nextPoint.radius;
                    const y2 = -Math.cos(nextPoint.angle) * nextPoint.radius;
                    
                    // Draw solid line for all segments
                    g.append("line")
                        .attr("x1", x1)
                        .attr("y1", y1)
                        .attr("x2", x2)
                        .attr("y2", y2)
                        .attr("stroke", colors(country.name))
                        .attr("stroke-width", 2);
                });
                
                // Draw filled polygon
                const pathString = pathPoints.map((point, i) => {
                    const x = Math.sin(point.angle) * point.radius;
                    const y = -Math.cos(point.angle) * point.radius;
                    return i === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
                }).join(" ") + " Z";
                
                g.append("path")
                    .attr("d", pathString)
                    .attr("fill", colors(country.name))
                    .attr("fill-opacity", 0.2);
                
                // Add points
                pathPoints.forEach((point, i) => {
                    const x = Math.sin(point.angle) * point.radius;
                    const y = -Math.cos(point.angle) * point.radius;
                    
                    g.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 4)
                        .attr("fill", colors(country.name))
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                });
            });
            
            // Add legend - positioned above the chart, stacked vertically
            const legend = svg.append("g")
                .attr("transform", `translate(${width / 2}, 10)`);
            
            // Create vertical legend layout
            let legendY = 0;
            
            // Add global mean to legend first
            if (globalMean) {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${legendY})`);
                
                legendItem.append("line")
                    .attr("x1", 0)
                    .attr("x2", 15)
                    .attr("y1", 7.5)
                    .attr("y2", 7.5)
                    .attr("stroke", globalMeanColor)
                    .attr("stroke-width", 2);
                
                legendItem.append("text")
                    .attr("x", 20)
                    .attr("y", 12)
                    .attr("font-size", "12px")
                    .attr("fill", "#333")
                    .text(globalMean.name);
                
                legendY += 25;
            }
            
            data.forEach((country, i) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${legendY})`);
                
                legendItem.append("rect")
                    .attr("width", 15)
                    .attr("height", 15)
                    .attr("fill", colors(country.name));
                
                legendItem.append("text")
                    .attr("x", 20)
                    .attr("y", 12)
                    .attr("font-size", "12px")
                    .attr("fill", "#333")
                    .text(country.name);
                
                legendY += 25;
            });
        }
        
        // Helper to check if value is missing
        function isMissing(v) {
            return v === null || v === undefined || v === "" || isNaN(+v);
        }

            // Helper to safely format numeric values
        function fmt(v, digits = 1) {
            if (isMissing(v)) return "Data not available";
                const num = +v;
                return Number.isInteger(num) ? num.toString() : num.toFixed(digits);
        }

        // Function to display country data as tree
        function displayCountryData(data, geoData) {
            // Clear previous trees
            d3.select("#tree-container").html("");
            d3.select("#data-description").remove();
            
            // Create tree for aggregate index
            createIndexTree(data);

            // Create tree for other statistics
            createOtherStatsTree(data);
            
            // Create description section
            createDataDescription(data);
            
            // Create bubble chart on the map
            createBubbleChart(data, geoData);
        }

        // Function to create data description section
        function createDataDescription(data) {
            const infoPanel = d3.select("#info-panel");
            const descriptionDiv = infoPanel.append("div").attr("id", "data-description");
            
            descriptionDiv.append("h4").text("Data Dimensions");
            
            const dimensions = [
                {
                    label: "Life expectancy at birth (years, 2023):",
                    value: data["life_expectancy_at_birth_2023_raw"]
                },
                {
                    label: "Population under 18 (millions, 2023):",
                    value: data["population_2023_thousands_under18"] ? (parseFloat(data["population_2023_thousands_under18"]) / 1000) : null
                },
                {
                    label: "Mortality rate (ages 5‚Äì14, 2022, per 100,000 children):",
                    value: data["among5_14_mortality_rate_2022_raw"]
                },
                {
                    label: "Primary school completion rate (2000‚Äì2023, %):",
                    value: data["completion_rate_2000_2023_primary_raw"]
                },
                {
                    label: "Households with basic sanitation services (%, 2022):",
                    value: data["basic_sanitation_household_perc_2022_raw"]
                },
                {
                    label: "Children with stunted growth (%, 2022):",
                    value: data["stunted_perc_2022_raw"]
                },
                {
                    label: "Mean annual PM2.5 exposure (¬µg/m¬≥):",
                    value: data["pm25_latest_raw"]
                },
                {
                    label: "Population with internet access (latest %, all ages):",
                    value: data["internet_latest_raw"]
                },
                {
                    label: "GDP per person (latest, US$ PPP or constant prices):",
                    value: data["gdp_latest_raw"]
                },
                {
                    label: "Happiness rank (World Happiness Report):",
                    value: data["happiness_rank_raw"]
                }
            ];
            
            dimensions.forEach(dim => {
                const digits = dim.label.includes("GDP") || dim.label.includes("rank") ? 0 : (dim.label.includes("millions") ? 2 : 1);
                descriptionDiv.append("p")
                    .html(`<strong>${dim.label}</strong> ${fmt(dim.value, digits)}`);
            });
        }

        // Function to create the aggregate index tree
        function createIndexTree(data) {
            const container = d3.select("#tree-container");
            const treeWrapper = container.append("div").attr("class", "tree-wrapper");
            
            const width = 500;
            const height = 350;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            
            const svg = treeWrapper.append("svg")
                .attr("class", "tree-svg")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Get aggregate index z-score
            const aggregateIndex = isMissing(data["child_wellbeing_index"]) ? null : parseFloat(data["child_wellbeing_index"]);
            
            // Define dimensions that contribute to aggregate index
            const indexDimensions = [
                {
                    name: "Mortality Rate (ages 5-14)",
                    rawValue: data["among5_14_mortality_rate_2022_raw"],
                    unit: "per 100k",
                    field: "among5_14_mortality_rate_2022_raw"
                },
                {
                    name: "Primary Completion",
                    rawValue: data["completion_rate_2000_2023_primary_raw"],
                    unit: "%",
                    field: "completion_rate_2000_2023_primary_raw"
                },
                {
                    name: "Basic Sanitation",
                    rawValue: data["basic_sanitation_household_perc_2022_raw"],
                    unit: "%",
                    field: "basic_sanitation_household_perc_2022_raw"
                },
                {
                    name: "Stunted Growth",
                    rawValue: data["stunted_perc_2022_raw"],
                    unit: "%",
                    field: "stunted_perc_2022_raw"
                },
                {
                    name: "Happiness Rank",
                    rawValue: data["happiness_rank_raw"],
                    unit: "",
                    field: "happiness_rank_raw"
                }
            ];

            // Build tree data structure
            const root = {
                name: "Aggregate Index",
                value: aggregateIndex,
                zScore: isMissing(aggregateIndex) ? "Data not available" : fmt(aggregateIndex, 2),
                children: indexDimensions.map(dim => ({
                    name: dim.name,
                    value: isMissing(dim.rawValue) ? null : parseFloat(dim.rawValue),
                    unit: dim.unit,
                    rawValue: dim.rawValue,
                    isMissing: isMissing(dim.rawValue)
                }))
            };
            
            // Create tree layout (horizontal: height is x, width is y)
            const treeLayout = d3.tree()
                .size([height - margin.top - margin.bottom - 40, width - margin.left - margin.right - 200]);
            
            const rootNode = d3.hierarchy(root);
            treeLayout(rootNode);
            
            // Draw links
            const links = g.selectAll(".tree-link")
                .data(rootNode.links())
                .enter()
                .append("path")
                .attr("class", "tree-link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y + 100)
                    .y(d => d.x));
            
            // Draw nodes
            const nodes = g.selectAll(".tree-node")
                .data(rootNode.descendants())
                .enter()
                .append("g")
                .attr("class", d => d.depth === 0 ? "tree-node root" : "tree-node leaf")
                .attr("transform", d => `translate(${d.y + 100},${d.x})`);
            
            // Add circles first (so they appear behind text)
            nodes.append("circle");
            
            // Add text labels (on top of circles)
            const textLabels = nodes.append("text")
                .attr("dy", d => d.depth === 0 ? -15 : 4)
                .attr("dx", d => d.depth === 0 ? 0 : 12)
                .attr("text-anchor", d => d.depth === 0 ? "middle" : "start")
                .text(d => d.data.name);

            // Add z-score for root node
            const zScoreLabels = nodes.filter(d => d.depth === 0)
                .append("text")
                .attr("class", "tree-value")
                .attr("dy", 20)
                .attr("dx", 0)
                .attr("text-anchor", "middle")
                .style("font-size", "11px")
                .style("fill", "#666")
                .text(d => {
                    if (d.data.zScore === "Data not available") {
                        return d.data.zScore;
                    }
                    return `z-score: ${d.data.zScore}`;
                });
            
            // Add values for leaf nodes
            nodes.filter(d => d.depth > 0)
                .append("text")
                .attr("class", "tree-value")
                .attr("dy", 16)
                .attr("dx", 12)
                .attr("text-anchor", "start")
                .text(d => {
                    if (d.data.isMissing) {
                        return "Data not available";
                    }
                    const val = fmt(d.data.value, d.data.unit === "%" ? 1 : (d.data.unit === "US$" ? 0 : 1));
                    return `${val} ${d.data.unit}`;
                });
        }

        // Function to create the other statistics tree
        function createOtherStatsTree(data) {
            const container = d3.select("#tree-container");
            const treeWrapper = container.append("div").attr("class", "tree-wrapper");
            
            const width = 500;
            const height = 350;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            
            const svg = treeWrapper.append("svg")
                .attr("class", "tree-svg")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Other statistics that don't contribute to aggregate index
            const otherStats = [
                {
                    name: "Life Expectancy",
                    rawValue: data["life_expectancy_at_birth_2023_raw"],
                    unit: "years",
                    field: "life_expectancy_at_birth_2023_raw"
                },
                {
                    name: "PM2.5 Exposure",
                    rawValue: data["pm25_latest_raw"],
                    unit: "¬µg/m¬≥",
                    field: "pm25_latest_raw"
                },
                {
                    name: "GDP per Capita",
                    rawValue: data["gdp_latest_raw"],
                    unit: "US$",
                    field: "gdp_latest_raw"
                },
                {
                    name: "Population <18",
                    rawValue: data["population_2023_thousands_under18"] ? (parseFloat(data["population_2023_thousands_under18"]) / 1000) : null,
                    unit: "millions",
                    field: "population_2023_thousands_under18"
                },
                {
                    name: "Internet Access",
                    rawValue: data["internet_latest_raw"],
                    unit: "%",
                    field: "internet_latest_raw"
                }
            ];
            
            // Build tree data structure
            const root = {
                name: "Other Statistics",
                children: otherStats.map(stat => ({
                    name: stat.name,
                    value: isMissing(stat.rawValue) ? null : parseFloat(stat.rawValue),
                    unit: stat.unit,
                    rawValue: stat.rawValue,
                    isMissing: isMissing(stat.rawValue)
                }))
            };
            
            // Create tree layout (horizontal: height is x, width is y)
            const treeLayout = d3.tree()
                .size([height - margin.top - margin.bottom - 40, width - margin.left - margin.right - 200]);
            
            const rootNode = d3.hierarchy(root);
            treeLayout(rootNode);
            
            // Draw links
            const links = g.selectAll(".tree-link")
                .data(rootNode.links())
                .enter()
                .append("path")
                .attr("class", "tree-link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y + 100)
                    .y(d => d.x));

            // Draw nodes
            const nodes = g.selectAll(".tree-node")
                .data(rootNode.descendants())
                .enter()
                .append("g")
                .attr("class", d => d.depth === 0 ? "tree-node root" : "tree-node leaf")
                .attr("transform", d => `translate(${d.y + 100},${d.x})`);
            
            // Add circles first (so they appear behind text)
            nodes.append("circle");
            
            // Add text labels (on top of circles)
            const textLabels = nodes.append("text")
                .attr("dy", d => d.depth === 0 ? -15 : 4)
                .attr("dx", d => d.depth === 0 ? 0 : 12)
                .attr("text-anchor", d => d.depth === 0 ? "middle" : "start")
                .text(d => d.data.name);
            
            // Add values for leaf nodes
            nodes.filter(d => d.depth > 0)
                .append("text")
                .attr("class", "tree-value")
                .attr("dy", 16)
                .attr("dx", 12)
                .attr("text-anchor", "start")
                .text(d => {
                    if (d.data.isMissing) {
                        return "Data not available";
                    }
                    const val = fmt(d.data.value, d.data.unit === "%" ? 1 : (d.data.unit === "millions" ? 2 : 1));
                    return `${val} ${d.data.unit}`;
                });
        }
        
        // Function to create bubble chart for the 5 key statistics on the map
        function createBubbleChart(data, countryGeoData) {
            // Remove any existing bubble overlay
            mapGroup.selectAll(".bubble-overlay").remove();
            
            // Define the 5 key statistics with both raw values (for display) and z-score fields (for coloring)
            const stats = [
                {
                    name: "Life Expectancy",
                    value: parseFloat(data["life_expectancy_at_birth_2023_raw"]) || 0,
                    unit: "years",
                    rawField: "life_expectancy_at_birth_2023_raw",
                    zScoreField: "life_expectancy_at_birth_2023"
                },
                {
                    name: "Happiness Rank",
                    value: parseFloat(data["happiness_rank_raw"]) || 0,
                    unit: "",
                    rawField: "happiness_rank_raw",
                    zScoreField: "happiness_rank"
                },
                {
                    name: "Mortality Rate",
                    value: parseFloat(data["among5_14_mortality_rate_2022_raw"]) || 0,
                    unit: "per 100k",
                    rawField: "among5_14_mortality_rate_2022_raw",
                    zScoreField: "among5_14_mortality_rate_2022"
                },
                {
                    name: "Primary Completion",
                    value: parseFloat(data["completion_rate_2000_2023_primary_raw"]) || 0,
                    unit: "%",
                    rawField: "completion_rate_2000_2023_primary_raw",
                    zScoreField: "completion_rate_2000_2023_primary"
                },
                {
                    name: "Basic Sanitation",
                    value: parseFloat(data["basic_sanitation_household_perc_2022_raw"]) || 0,
                    unit: "%",
                    rawField: "basic_sanitation_household_perc_2022_raw",
                    zScoreField: "basic_sanitation_household_perc_2022"
                }
            ];
            
            // Filter out stats with no data
            const validStats = stats.filter(s => s.value > 0);
            
            if (validStats.length === 0) {
                return;
            }
            
            // Calculate position - use the population bubble's position
            let bubbleX, bubbleY;
            const bubbleChartRadius = 100; // Approximate radius of the bubble chart (for boundary checking)
            
            if (countryGeoData) {
                const centroid = path.centroid(countryGeoData);
                bubbleX = centroid[0];
                bubbleY = centroid[1];
                
                // Only adjust if bubble would be off-screen, keep it within bounds
                if (bubbleX < bubbleChartRadius) bubbleX = bubbleChartRadius;
                if (bubbleX > width - bubbleChartRadius) bubbleX = width - bubbleChartRadius;
                if (bubbleY < bubbleChartRadius) bubbleY = bubbleChartRadius;
                if (bubbleY > height - bubbleChartRadius) bubbleY = height - bubbleChartRadius;
            } else {
                // Default position (center)
                bubbleX = width / 2;
                bubbleY = height / 2;
            }
            
            // Bubble chart dimensions - smaller and more compact
            const bubbleRadius = 25; // Smaller fixed size for all bubbles
            const chartWidth = 220;
            const chartHeight = 180;
            
            // Create overlay group - centered on the position (in mapGroup so it zooms with map)
            const overlay = mapGroup.append("g")
                .attr("class", "bubble-overlay")
                .attr("transform", `translate(${bubbleX}, ${bubbleY})`);
            
            // Position bubbles in a circle - all same size, tighter spacing
            const centerX = 0;
            const centerY = 0;
            const radius = 50; // Distance from center - smaller
            
            validStats.forEach((stat, i) => {
                const angle = (i * 2 * Math.PI) / validStats.length - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Determine bubble color based on z-score using magma scale
                let bubbleColor = "#e0e0e0"; // Default grey if no z-score available
                
                if (stat.zScoreField && data[stat.zScoreField] !== undefined && data[stat.zScoreField] !== "") {
                    const zScore = parseFloat(data[stat.zScoreField]);
                    if (!isNaN(zScore)) {
                        // Build a magma color scale for this specific statistic based on all countries' z-scores
                        const allRows = Object.values(countryData || {});
                        const zScores = allRows
                            .map(d => parseFloat(d[stat.zScoreField]))
                            .filter(v => !isNaN(v));
                        
                        if (zScores.length > 0) {
                            const extent = d3.extent(zScores);
                            const statColorScale = d3.scaleSequential(d3.interpolateMagma)
                                .domain(extent);
                            bubbleColor = statColorScale(zScore);
                        }
                    }
                }
                
                // Calculate final positions
                let labelRadius = radius + bubbleRadius + 15; // Position label outside the bubble
                let labelX = centerX + labelRadius * Math.cos(angle);
                let labelY = centerY + labelRadius * Math.sin(angle);
                
                // Apply special offsets for specific labels
                if (stat.name === "Basic Sanitation") {
                    // Offset up-left: move up and left
                    labelX -= 15;
                    labelY -= 10;
                } else if (stat.name === "Happiness Rank") {
                    // Offset up-right: move up and right
                    labelX += 15;
                    labelY -= 10;
                }
                
                // Draw bubble starting at center, then animate to final position
                const bubble = overlay.append("circle")
                    .attr("class", "bubble")
                    .attr("cx", centerX)
                    .attr("cy", centerY)
                    .attr("r", 0)
                    .attr("fill", bubbleColor)
                    .attr("data-stat", stat.name)
                    .on("mouseover", function(event) {
                        d3.select(this).attr("stroke-width", 3);
                        showBubbleTooltip(event, stat);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("stroke-width", 2);
                        hideBubbleTooltip();
                    });
                
                // Animate bubble emerging from center
                bubble.transition()
                    .duration(600)
                    .ease(d3.easeCubicOut)
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", bubbleRadius);
                
                // Add value label inside bubble (center) - start at center, animate with bubble
                const fmtValue = stat.value >= 1000 ? 
                    (stat.value / 1000).toFixed(1) + "k" : 
                    stat.value.toFixed(stat.unit === "%" ? 1 : 0);
                const valueText = overlay.append("text")
                    .attr("class", "bubble-value")
                    .attr("x", centerX)
                    .attr("y", centerY + 2)
                    .text(fmtValue)
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .style("opacity", 0);
                
                valueText.transition()
                    .duration(600)
                    .ease(d3.easeCubicOut)
                    .delay(200)
                    .attr("x", x)
                    .attr("y", y + 2)
                    .style("opacity", 1);
                
                // Add unit label inside bubble (below value) - start at center, animate with bubble
                const unitText = overlay.append("text")
                    .attr("class", "bubble-value")
                    .attr("x", centerX)
                    .attr("y", centerY + 14)
                    .text(stat.unit)
                    .style("font-size", "8px")
                    .style("opacity", 0);
                
                unitText.transition()
                    .duration(600)
                    .ease(d3.easeCubicOut)
                    .delay(200)
                    .attr("x", x)
                    .attr("y", y + 14)
                    .style("opacity", 1);
                
                // Add connecting line from bubble to label - start at center, animate
                const connectorLine = overlay.append("line")
                    .attr("class", "bubble-label-connector")
                    .attr("x1", centerX)
                    .attr("y1", centerY)
                    .attr("x2", centerX)
                    .attr("y2", centerY)
                    .attr("stroke", "#666")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "2,2")
                    .style("opacity", 0);
                
                connectorLine.transition()
                    .duration(600)
                    .ease(d3.easeCubicOut)
                    .delay(400)
                    .attr("x1", x)
                    .attr("y1", y)
                    .attr("x2", labelX)
                    .attr("y2", labelY)
                    .style("opacity", 0.6);
                
                // Create a group for the label with background - start at center, animate to final position
                const labelGroup = overlay.append("g")
                    .attr("class", "bubble-dimension-label-group")
                    .attr("transform", `translate(${centerX}, ${centerY})`)
                    .style("opacity", 0);
                
                // Add text first to measure it
                const labelText = labelGroup.append("text")
                    .attr("class", "bubble-dimension-label")
                    .attr("x", 0)
                    .attr("y", 0)
                    .text(stat.name)
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .style("fill", "#333")
                    .style("text-anchor", "middle")
                    .style("dominant-baseline", "middle");
                
                // Get text bounding box and add white background rectangle
                const textBBox = labelText.node().getBBox();
                const padding = 4;
                labelGroup.insert("rect", "text")
                    .attr("x", textBBox.x - padding)
                    .attr("y", textBBox.y - padding)
                    .attr("width", textBBox.width + (padding * 2))
                    .attr("height", textBBox.height + (padding * 2))
                    .attr("fill", "white")
                    .attr("stroke", "#333")
                    .attr("stroke-width", 0.5)
                    .attr("rx", 2);
                
                // Animate label group from center to final position
                labelGroup.transition()
                    .duration(600)
                    .ease(d3.easeCubicOut)
                    .delay(500)
                    .attr("transform", `translate(${labelX}, ${labelY})`)
                    .style("opacity", 1);
            });
            
        }
        
        // Bubble chart tooltip
        function showBubbleTooltip(event, stat) {
            tooltip
                .style("opacity", 1)
                .html(`<strong>${stat.name}</strong><br/>${stat.value.toFixed(1)} ${stat.unit}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }
        
        function hideBubbleTooltip() {
            tooltip.style("opacity", 0);
        }
        
        // Function to load CSV data
        function loadCountryData(csvPath) {
            d3.csv(csvPath)
                .then(function(data) {
                    // Process CSV data
                    data.forEach(function(row) {
                        // The main identifier in this CSV is the "country" column
                        const countryName = row["country"];
                        if (countryName) {
                            // Store all data for this country
                            countryData[countryName] = row;
                        }
                    });
                    
                    console.log(`Loaded data for ${Object.keys(countryData).length} countries`);

                    // Reset color scale so it is rebuilt for the active metric
                    wellbeingColorScale = null;

                    // Apply colors to any already-rendered countries
                    updateCountryColors();
                    
                    // Update legend to show current metric
                    updateLegend();
                    
                    // If a country is currently selected, update its display
                    if (selectedCountry) {
                        const data = findCountryData(selectedCountry);
                        if (data) {
                            // Find the geo data for the selected country
                            const geoFeature = countries.features.find(d => 
                                (d.properties.NAME || d.properties.name || "Unknown") === selectedCountry
                            );
                            displayCountryData(data, geoFeature);
                        }
                    }
                })
                .catch(function(error) {
                    console.error("Error loading CSV:", error);
                });
        }
        
        // Metric filter controls (radio buttons)
        const metricInputs = document.querySelectorAll('input[name="metric-filter"]');
        metricInputs.forEach(input => {
            input.addEventListener("change", function() {
                if (!this.checked) return;
                activeMetricKey = this.value;
                wellbeingColorScale = null; // force rebuild for new metric
                updateCountryColors();
                updateLegend(); // Update legend to show current metric
            });
        });

        // Function to show tooltip
        function showTooltip(event, countryName) {
            tooltip
                .style("opacity", 1)
                .html(countryName)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }
        
        // Function to hide tooltip
        function hideTooltip() {
            tooltip.style("opacity", 0);
        }
        
        // Function to create the static legend on the left side
        function createBubbleLegend() {
            const legendContainer = document.getElementById("legend-items");
            if (!legendContainer) return;
            
            legendContainer.innerHTML = "";
            
            // Section 1: Map Color Scale
            const colorScaleSection = document.createElement("div");
            colorScaleSection.className = "legend-section";
            
            const colorScaleTitle = document.createElement("div");
            colorScaleTitle.className = "legend-section-title";
            colorScaleTitle.textContent = "Map Color Scale";
            colorScaleSection.appendChild(colorScaleTitle);
            
            const scaleDiv = document.createElement("div");
            scaleDiv.className = "legend-color-scale";
            colorScaleSection.appendChild(scaleDiv);
            
            const scaleLabels = document.createElement("div");
            scaleLabels.className = "legend-scale-labels";
            scaleLabels.innerHTML = "<span>Low</span><span>High</span>";
            colorScaleSection.appendChild(scaleLabels);
            
            const currentMetric = metricConfig[activeMetricKey];
            if (currentMetric) {
                const metricLabel = document.createElement("div");
                metricLabel.className = "legend-item-text";
                metricLabel.style.marginTop = "4px";
                metricLabel.style.fontStyle = "italic";
                metricLabel.textContent = `Current: ${currentMetric.label}`;
                colorScaleSection.appendChild(metricLabel);
            }
            
            legendContainer.appendChild(colorScaleSection);
            
            // Section 2: Country States
            const statesSection = document.createElement("div");
            statesSection.className = "legend-section";
            
            const statesTitle = document.createElement("div");
            statesTitle.className = "legend-section-title";
            statesTitle.textContent = "Country States";
            statesSection.appendChild(statesTitle);
            
            // Selected country
            const selectedDiv = document.createElement("div");
            selectedDiv.className = "legend-item-container";
            const selectedOutline = document.createElement("div");
            selectedOutline.className = "legend-outline";
            const selectedText = document.createElement("div");
            selectedText.className = "legend-item-text";
            selectedText.textContent = "Selected country";
            selectedDiv.appendChild(selectedOutline);
            selectedDiv.appendChild(selectedText);
            statesSection.appendChild(selectedDiv);
            
            // Hover state
            const hoverDiv = document.createElement("div");
            hoverDiv.className = "legend-item-container";
            const hoverOutline = document.createElement("div");
            hoverOutline.className = "legend-outline-hover";
            const hoverText = document.createElement("div");
            hoverText.className = "legend-item-text";
            hoverText.textContent = "Hover";
            hoverDiv.appendChild(hoverOutline);
            hoverDiv.appendChild(hoverText);
            statesSection.appendChild(hoverDiv);
            
            // No data
            const noDataDiv = document.createElement("div");
            noDataDiv.className = "legend-item-container";
            const noDataBox = document.createElement("div");
            noDataBox.className = "legend-grey";
            const noDataText = document.createElement("div");
            noDataText.className = "legend-item-text";
            noDataText.textContent = "No data available";
            noDataDiv.appendChild(noDataBox);
            noDataDiv.appendChild(noDataText);
            statesSection.appendChild(noDataDiv);
            
            legendContainer.appendChild(statesSection);
            
            // Section 4: Bubble Chart Statistics - REMOVED
            // Bubble chart explanation is now in the description box
        }
        
        // Function to update the legend when metric changes
        function updateLegend() {
            createBubbleLegend();
        }
        
        // Create the static legend on page load
        createBubbleLegend();
        
        // Add collapsible functionality to legend
        const legendToggle = document.getElementById("legend-toggle");
        const legend = document.getElementById("bubble-legend");
        if (legendToggle && legend) {
            legendToggle.addEventListener("click", function() {
                legend.classList.toggle("collapsed");
            });
        }
        
        // View toggle functionality
        const defaultViewBtn = document.getElementById("default-view-btn");
        const comparisonViewBtn = document.getElementById("comparison-view-btn");
        
        if (defaultViewBtn && comparisonViewBtn) {
            defaultViewBtn.addEventListener("click", function() {
                comparisonMode = false;
                defaultViewBtn.classList.add("active");
                comparisonViewBtn.classList.remove("active");
                
                // Update subtitle
                document.getElementById("subtitle").textContent = "Click on any country to view its data ‚Ä¢ Scroll to zoom, drag to pan. Scroll down to see specific statistics.";
                
                // Clear comparison selections
                comparisonCountries = [];
                mapGroup.selectAll(".country")
                    .classed("selected-1", false)
                    .classed("selected-2", false);
                
                // Remove bubble chart overlay
                mapGroup.selectAll(".bubble-overlay").remove();
                
                // Hide comparison panel, show info panel
                d3.select("#comparison-panel").classed("active", false);
                d3.select("#info-panel").style("display", "block");
                
                // Update legend
                updateLegend();
            });
            
            comparisonViewBtn.addEventListener("click", function() {
                comparisonMode = true;
                comparisonViewBtn.classList.add("active");
                defaultViewBtn.classList.remove("active");
                
                // Update subtitle
                document.getElementById("subtitle").textContent = "Click on countries to select them for comparison. Select multiple countries to compare their statistics on the radar chart below.";
                
                // Clear single selection
                selectedCountry = null;
                mapGroup.selectAll(".country").classed("selected", false);
                
                // Remove bubble chart overlay
                mapGroup.selectAll(".bubble-overlay").remove();
                
                // Hide info panel
                d3.select("#info-panel").style("display", "none");
                
                // Show comparison panel with empty state
                updateComparisonDisplay();
                
                // Update legend
                updateLegend();
                
                // Advance tutorial if waiting for comparison view click
                advanceTutorialOnAction("comparisonViewClick");
            });
        }
        
        // Clear selection button
        const clearSelectionBtn = document.getElementById("clear-selection-btn");
        if (clearSelectionBtn) {
            clearSelectionBtn.addEventListener("click", function() {
                clearComparisonSelections();
            });
        }
        
        // Tutorial system
        let currentTutorialStep = 0;
        const tutorialSteps = [
            {
                title: "Welcome to the Tutorial",
                text: "This interactive visualization shows global children's wellbeing data. Let's explore its features step by step!",
                highlight: null,
                scrollTo: null,
                interactive: false
            },
            {
                title: "Selecting a Country",
                text: "Click on any country on the map to view its detailed data. The map uses color encoding to show different metrics. Try clicking on a country now!",
                highlight: "#map-svg-container",
                scrollTo: "#map-container",
                interactive: true,
                waitFor: "countryClick"
            },
            {
                title: "Branching Bubbles",
                text: "When you select a country, branching bubbles appear on the map showing key data dimensions. Each bubble's color encodes the z-score of that dimension. Did you catch them emerging from the center?",
                highlight: ".bubble-overlay",
                scrollTo: "#map-svg-container",
                interactive: false,
                positionContent: "right"
            },
            {
                title: "Color Encoding Filter",
                text: "Use the 'Colour by' radio buttons in the legend to change what metric is encoded in the map colors. You can view Aggregate Index, Happiness Rank, Child Mortality, and more.",
                highlight: "#metric-controls",
                scrollTo: "#bubble-legend",
                interactive: false
            },
            {
                title: "Info Display Panel",
                text: "Below the map, you'll see detailed information about the selected country, including tree visualizations of the aggregate index and other statistics. This panel pops up when a country is selected.",
                highlight: "#info-panel",
                scrollTo: "#info-panel",
                interactive: false
            },
            {
                title: "Switching to Comparison View",
                text: "Click the 'Comparison View' button at the top to switch modes. This allows you to compare multiple countries side by side.",
                highlight: "#comparison-view-btn",
                scrollTo: ".view-toggle",
                interactive: true,
                waitFor: "comparisonViewClick"
            },
            {
                title: "Selecting Countries for Comparison",
                text: "In Comparison View, click on countries to add them to the comparison. You can select more than just two countries! Selected countries are highlighted with colored borders. Try selecting a country right now!",
                highlight: "#map-svg-container",
                scrollTo: "#map-container",
                interactive: true,
                waitFor: "comparisonCountryClick"
            },
            {
                title: "Radar Chart",
                text: "When you select countries in Comparison View, a radar chart appears at the bottom showing how they compare across different dimensions. The chart uses z-scores normalized to a 0-100 scale.",
                highlight: "#comparison-radar-container",
                scrollTo: "#comparison-panel",
                interactive: false,
                forceScroll: true
            }
        ];
        
        function getElementPosition(selector) {
            // Handle multiple elements (like .bubble-overlay)
            const elements = document.querySelectorAll(selector);
            if (elements.length === 0) return null;
            
            // If multiple elements, get bounding box of all
            if (elements.length > 1) {
                let minTop = Infinity, minLeft = Infinity, maxBottom = -Infinity, maxRight = -Infinity;
                elements.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    minTop = Math.min(minTop, rect.top);
                    minLeft = Math.min(minLeft, rect.left);
                    maxBottom = Math.max(maxBottom, rect.bottom);
                    maxRight = Math.max(maxRight, rect.right);
                });
                return {
                    top: minTop + window.scrollY,
                    left: minLeft + window.scrollX,
                    width: maxRight - minLeft,
                    height: maxBottom - minTop
                };
            }
            
            const element = elements[0];
            const rect = element.getBoundingClientRect();
            return {
                top: rect.top + window.scrollY,
                left: rect.left + window.scrollX,
                width: rect.width,
                height: rect.height
            };
        }
        
        function highlightElement(selector) {
            const highlight = document.getElementById("tutorial-highlight");
            if (!selector) {
                highlight.style.display = "none";
                return;
            }
            
            // Wait a bit for dynamic elements
            setTimeout(() => {
                const elements = document.querySelectorAll(selector);
                if (elements.length === 0) {
                    highlight.style.display = "none";
                    // Center content if no highlight
                    const content = document.getElementById("tutorial-content");
                    content.style.top = "50%";
                    content.style.left = "50%";
                    content.style.transform = "translate(-50%, -50%)";
                    return;
                }
                
                // Get bounding box of all matching elements
                let minTop = Infinity, minLeft = Infinity, maxBottom = -Infinity, maxRight = -Infinity;
                elements.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    minTop = Math.min(minTop, rect.top);
                    minLeft = Math.min(minLeft, rect.left);
                    maxBottom = Math.max(maxBottom, rect.bottom);
                    maxRight = Math.max(maxRight, rect.right);
                });
                
                highlight.style.display = "block";
                highlight.style.top = minTop + "px";
                highlight.style.left = minLeft + "px";
                highlight.style.width = (maxRight - minLeft) + "px";
                highlight.style.height = (maxBottom - minTop) + "px";
                
                positionTutorialContent();
            }, 100);
        }
        
        function scrollToElement(selector) {
            if (!selector) return;
            const element = document.querySelector(selector);
            if (element) {
                element.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }
        
        function positionTutorialContent(position = "auto") {
            const content = document.getElementById("tutorial-content");
            const highlight = document.getElementById("tutorial-highlight");
            
            if (highlight.style.display === "none" || highlight.style.display === "") {
                // Center the content
                content.style.top = "50%";
                content.style.left = "50%";
                content.style.transform = "translate(-50%, -50%)";
            } else {
                // Position near the highlight
                const highlightRect = highlight.getBoundingClientRect();
                const contentRect = content.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                let top, left;
                
                if (position === "right") {
                    // Position to the right of the highlight
                    left = highlightRect.right + 20;
                    top = highlightRect.top + (highlightRect.height / 2) - (contentRect.height / 2);
                    
                    // Adjust if content would go off screen
                    if (left + contentRect.width > viewportWidth) {
                        left = highlightRect.left - contentRect.width - 20;
                    }
                    if (top + contentRect.height > viewportHeight) {
                        top = viewportHeight - contentRect.height - 20;
                    }
                    if (top < 20) {
                        top = 20;
                    }
                } else {
                    // Default: position below or above
                    top = highlightRect.bottom + 20;
                    left = highlightRect.left;
                    
                    // Adjust if content would go off screen
                    if (top + contentRect.height > viewportHeight) {
                        top = highlightRect.top - contentRect.height - 20;
                    }
                    if (top < 20) {
                        top = 20;
                    }
                    if (left + contentRect.width > viewportWidth) {
                        left = viewportWidth - contentRect.width - 20;
                    }
                    if (left < 20) {
                        left = 20;
                    }
                }
                
                content.style.top = top + "px";
                content.style.left = left + "px";
                content.style.transform = "none";
            }
        }
        
        function showTutorialStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= tutorialSteps.length) return;
            
            currentTutorialStep = stepIndex;
            const step = tutorialSteps[stepIndex];
            
            document.getElementById("tutorial-title").textContent = step.title;
            document.getElementById("tutorial-text").textContent = step.text;
            document.getElementById("tutorial-step-indicator").textContent = `Step ${stepIndex + 1} of ${tutorialSteps.length}`;
            
            // Update navigation buttons - hide next for interactive steps
            const nextBtn = document.getElementById("tutorial-next");
            const prevBtn = document.getElementById("tutorial-prev");
            
            prevBtn.disabled = stepIndex === 0;
            
            if (step.interactive) {
                nextBtn.style.display = "none";
            } else {
                nextBtn.style.display = "block";
                nextBtn.textContent = stepIndex === tutorialSteps.length - 1 ? "Finish" : "Next";
            }
            
            // Enable/disable overlay interactions and dimming
            const overlay = document.getElementById("tutorial-overlay");
            if (step.interactive) {
                overlay.classList.add("interactive");
                // Remove dimming for interactive steps
                overlay.style.backgroundColor = "rgba(0, 0, 0, 0)";
            } else {
                overlay.classList.remove("interactive");
                // Add dimming for non-interactive steps
                overlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            }
            
            // Force switch to default view for step 2 (selecting a country)
            if (stepIndex === 1 && comparisonMode) {
                // Switch to default view
                comparisonMode = false;
                const defaultViewBtn = document.getElementById("default-view-btn");
                const comparisonViewBtn = document.getElementById("comparison-view-btn");
                if (defaultViewBtn && comparisonViewBtn) {
                    defaultViewBtn.classList.add("active");
                    comparisonViewBtn.classList.remove("active");
                }
                
                // Clear comparison selections
                comparisonCountries = [];
                mapGroup.selectAll(".country")
                    .classed("selected-1", false)
                    .classed("selected-2", false);
                
                // Remove bubble chart overlay
                mapGroup.selectAll(".bubble-overlay").remove();
                
                // Hide comparison panel, show info panel
                d3.select("#comparison-panel").classed("active", false);
                d3.select("#info-panel").style("display", "block");
                
                // Update legend
                updateLegend();
            }
            
            // Scroll to element
            if (step.scrollTo) {
                scrollToElement(step.scrollTo);
            }
            
            // Force scroll to bottom for radar chart
            if (step.forceScroll) {
                setTimeout(() => {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
                }, 500);
            }
            
            // Highlight element
            setTimeout(() => {
                highlightElement(step.highlight);
                positionTutorialContent(step.positionContent || "auto");
            }, 500);
        }
        
        function advanceTutorialOnAction(action) {
            const step = tutorialSteps[currentTutorialStep];
            if (step && step.waitFor === action) {
                setTimeout(() => {
                    nextTutorialStep();
                }, 500);
            }
        }
        
        function startTutorial() {
            document.getElementById("tutorial-overlay").classList.add("active");
            showTutorialStep(0);
        }
        
        function closeTutorial() {
            document.getElementById("tutorial-overlay").classList.remove("active");
            document.getElementById("tutorial-highlight").style.display = "none";
        }
        
        function nextTutorialStep() {
            if (currentTutorialStep < tutorialSteps.length - 1) {
                showTutorialStep(currentTutorialStep + 1);
            } else {
                closeTutorial();
            }
        }
        
        function prevTutorialStep() {
            if (currentTutorialStep > 0) {
                showTutorialStep(currentTutorialStep - 1);
            }
        }
        
        // Tutorial event listeners
        document.getElementById("tutorial-btn").addEventListener("click", startTutorial);
        document.getElementById("tutorial-close").addEventListener("click", closeTutorial);
        document.getElementById("tutorial-next").addEventListener("click", nextTutorialStep);
        document.getElementById("tutorial-prev").addEventListener("click", prevTutorialStep);
        
        // Update tutorial content position on scroll/resize
        window.addEventListener("scroll", positionTutorialContent);
        window.addEventListener("resize", () => {
            if (document.getElementById("tutorial-overlay").classList.contains("active")) {
                highlightElement(tutorialSteps[currentTutorialStep].highlight);
                positionTutorialContent();
            }
        });
        
        // Load CSV data automatically
        // Uses worldchildwellbeing3 (1).csv, which contains Z‚Äëscores and *_raw values
        loadCountryData("worldchildwellbeing3 (1).csv");
    </script>
</body>
</html>
